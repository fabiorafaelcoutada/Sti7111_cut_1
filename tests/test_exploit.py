import unittest
import os
import sys
from unittest.mock import patch, MagicMock

# Ensure src is in path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'src')))

from serial_exploit import send_exploit, parse_commands

class TestExploit(unittest.TestCase):
    def test_parse_commands(self):
        content = "SLEEP 1.0\nCMD poke 1234 5678"
        commands = parse_commands(content)
        self.assertEqual(len(commands), 2)
        self.assertEqual(commands[0], ('SLEEP', 1.0))
        self.assertEqual(commands[1], ('CMD', 'poke 1234 5678'))

    @patch('serial.Serial')
    def test_send_exploit(self, mock_serial_cls):
        # Create a mock instance
        mock_instance = MagicMock()
        mock_serial_cls.return_value = mock_instance

        # Create a dummy exploit file
        test_file = 'test_exploit.txt'
        with open(test_file, 'w') as f:
            f.write("CMD poke test test")

        try:
            # Note: We are testing the real Serial call logic
            result = send_exploit('/dev/ttyUSB0', baudrate=115200, commands_file=test_file)
            self.assertEqual(result['status'], 'success')
            mock_serial_cls.assert_called_with('/dev/ttyUSB0', 115200, write_timeout=0.5)
            # The CMD is "poke test test", so we expect a write call with that + newline encoded
            expected_call = b"poke test test\n"
            mock_instance.write.assert_called_with(expected_call)
        finally:
            if os.path.exists(test_file):
                os.remove(test_file)

if __name__ == '__main__':
    unittest.main()
