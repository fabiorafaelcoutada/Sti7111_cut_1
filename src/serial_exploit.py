#!/usr/bin/env python3
import serial
import time
import argparse
import sys
import os

class MockSerial:
    def __init__(self, port, baudrate, **kwargs):
        self.port = port
        self.baudrate = baudrate
        self.is_open = True
        print(f"[MOCK] Opened serial port {port} at {baudrate} baud.")

    def write(self, data):
        print(f"[MOCK] Writing: {data}")

    def flush(self):
        print(f"[MOCK] Flushed.")

    def close(self):
        self.is_open = False
        print(f"[MOCK] Closed serial port.")

def parse_commands(content):
    commands = []
    for line in content.splitlines():
        line = line.strip()
        if not line or line.startswith('#'):
            continue
        if line.startswith('SLEEP'):
            try:
                parts = line.split()
                if len(parts) > 1:
                    commands.append(('SLEEP', float(parts[1])))
            except ValueError:
                print(f"Warning: Invalid sleep duration in line: {line}")
        elif line.startswith('CMD'):
            # Extract everything after 'CMD '
            if len(line) > 4:
                cmd = line[4:]
                commands.append(('CMD', cmd))
    return commands

def send_exploit(port, baudrate=115200, commands_file=None):
    """
    Sends exploit commands over serial.
    Returns: dict with status and message.
    """
    if commands_file is None:
        # Default file in src/exploits/default.txt
        commands_file = os.path.join(os.path.dirname(__file__), 'exploits', 'default.txt')

    if not os.path.exists(commands_file):
        return {"status": "error", "message": f"Exploit file {commands_file} not found."}

    print(f"Loading exploit from {commands_file}...")
    try:
        with open(commands_file, 'r') as f:
            content = f.read()
    except Exception as e:
        return {"status": "error", "message": f"Failed to read exploit file: {str(e)}"}

    commands = parse_commands(content)
    print(f"Parsed {len(commands)} commands.")

    ser = None
    try:
        if port == "mock":
            ser = MockSerial(port, baudrate)
        else:
            ser = serial.Serial(port, baudrate, write_timeout=0.5)
            print(f"Opened serial port {port} at {baudrate} baud.")
    except serial.SerialException as e:
        return {"status": "error", "message": f"Error opening serial port: {str(e)}"}

    try:
        for cmd_type, value in commands:
            if cmd_type == 'SLEEP':
                print(f"Sleeping for {value} seconds...")
                time.sleep(value)
            elif cmd_type == 'CMD':
                print(f"Sending: {value}")
                ser.write((value + '\n').encode('utf-8'))
                ser.flush()
        return {"status": "success", "message": f"Sent {len(commands)} commands successfully."}
    except Exception as e:
        return {"status": "error", "message": f"Error during exploit execution: {str(e)}"}
    finally:
        if ser and ser.is_open:
            ser.close()
            print("Serial port closed.")

def main():
    parser = argparse.ArgumentParser(description="Send Serial Exploit Payload")
    parser.add_argument("port", help="Serial port (e.g., /dev/ttyUSB0) or 'mock'")
    parser.add_argument("--baudrate", type=int, default=115200, help="Baud rate (default: 115200)")
    parser.add_argument("--file", help="Path to custom exploit file", default=None)
    args = parser.parse_args()

    result = send_exploit(args.port, args.baudrate, args.file)
    print(result)
    if result["status"] == "error":
        sys.exit(1)

if __name__ == "__main__":
    main()
